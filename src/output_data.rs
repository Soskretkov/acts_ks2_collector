// У нас три вида источников откуда берутся данные на выходе: шапка атка, итоги акта, или же расчитываются программой
enum DataSource {
    InTableHeader(&'static str),
    AtCurrentPrices(&'static str),
    AtBasePrices(&'static str),
    Calculate,
}

// Нужен код, который будет назначать длину таблицы по горизонтали в зависимости от количества строк в итогах (обычно итоги имеют 17 строк,
// но если какой-то акт имеет 16, 18, 0 или, скажем, 40 строк в итогах, то нужна какая-то логика, чтобы соотнести эти 40 строк одного акта
// с 17 строками других актов. Нужно решение, как не сокращать эти 40 строк до 17 стандартных и выдать информацию пользователю без потерь.
// Таким образом у нас данные условно делятся на ожидаемые и случайные

// Нам нужна структура, содержащая информацию о колонках, которые мы ожидаем получить из актов, и нам нужно задать порядок, в котором мы хотим их вывести.
// У нас есть похожая - NAMES_OF_HEADER, но по разным причинам мы не будем ее использовать,
// Мы можем составить представление о начале заголовка выходной формы, читая кортеж схематично: ("как назвать", "где искать"):
// Позиция кортежа в массиве будет соответсвовать столбцу выходной формы (и это самые крайние левые столбцы шапки):

#[rustfmt::skip]
const _REPORTING_FORM_HEADER_PART_1: [(&'static str, DataSource); 18] = [
    ("Исполнитель", DataSource::InTableHeader("Исполнитель")),
    ("Глава", DataSource::Calculate),
    ("Объект", DataSource::InTableHeader("Объект")),
    ("Стоимость материальных ресурсов (всего) ТЦ", DataSource::AtCurrentPrices("Стоимость материальных ресурсов (всего)")),
    ("Договор №", DataSource::InTableHeader("Договор №")),
    ("Договор дата", DataSource::InTableHeader("Договор дата")),
    ("Эксплуатация машин БЦ", DataSource::AtBasePrices("Эксплуатация машин")),
    ("Смета №", DataSource::InTableHeader("Смета №")),
    ("Смета наименование", DataSource::InTableHeader("Смета наименование")),
    ("По смете в ц.2000г.", DataSource::InTableHeader("По смете в ц.2000г.")),
    ("Выполнение работ в ц.2000г.", DataSource::InTableHeader("Выполнение работ в ц.2000г.")),
    ("Акт №", DataSource::InTableHeader("Акт №")),
    ("Акт дата", DataSource::InTableHeader("Акт дата")),
    ("Отчетный период начало", DataSource::InTableHeader("Отчетный период начало")),
    ("Отчетный период окончание", DataSource::InTableHeader("Отчетный период окончание")),
    ("Метод расчета", DataSource::InTableHeader("Метод расчета")),
    ("Ссылка на папку", DataSource::Calculate),
    ("Ссылка на файл", DataSource::Calculate),
];

// В массиве выше перечислены далеко не все столбцы что будут в акте (а там может быть все что угодно и в неизвестном количестве), входим в зону неизвестности
// В данной программе столбцы будут делиться на два вида: по форме первого акта и не по его форме.
// Столбцы, которые будут совпадать со структурой первого акта, получают больший приоритет и стремятся в левое положение таблицы.
// Другими словами наша структура шапки воспроизведет порядок из итогов первого акта в выборке. А все что не встретилось в первом файле окажется правее
// Придется учесть, что у нас два вида данных в итогах: ьазовые и текущие цены. Придется проеделать описанное здесь для каждого вида цены.
// И конечно, нажно проверять на присутсвие вида данных в PART_1, что-бы мы не включили в шапку отчета повторяющиеся названия и могли составлять PART_1 как душе угодно