
use crate::TotalsRow;

// Четыре вида данных на выходе: в готовом виде в шапке, в готов виде в итогах акта (2 варанта), и нет готовых и нужно расчитать программой:
#[derive(PartialEq)]
pub enum DataSource {
    InTableHeader(&'static str),
    AtCurrentPrices(&'static str),
    AtBasePrices(&'static str),
    Calculate,
}

// Нужен код, который будет назначать длину таблицы по горизонтали в зависимости от количества строк в итогах (обычно итоги имеют 17 строк,
// но если какой-то акт имеет 16, 18, 0 или, скажем, 40 строк в итогах, то нужна какая-то логика, чтобы соотнести эти 40 строк одного акта
// с 17 строками других актов. Нужно решение, как не сокращать эти 40 строк до 17 стандартных и выдать информацию пользователю без потерь.
// Таким образом у нас данные условно делятся на ожидаемые и случайные

// Нам нужна структура, содержащая информацию о колонках, которые мы ожидаем получить из актов, и здесь мы будем задавать порядок, который хочет пользователь.
// Мы можем составить представление о начале заголовка выходной формы, читая кортеж схематично: ("как назвать", "где искать"):
// Позиция кортежа в массиве будет соответсвовать столбцу выходной формы (и это самые крайние левые столбцы шапки):

#[rustfmt::skip]
pub const REPORTING_FORM_PART_1: [(&'static str, DataSource); 18] = [
    ("Исполнитель", DataSource::InTableHeader("Исполнитель")),
    ("Глава", DataSource::Calculate),
    ("Объект", DataSource::InTableHeader("Объект")),
    ("Стоимость материальных ресурсов (всего) ТЦ", DataSource::AtCurrentPrices("Стоимость материальных ресурсов (всего)")),
    ("Договор №", DataSource::InTableHeader("Договор №")),
    ("Договор дата", DataSource::InTableHeader("Договор дата")),
    ("Эксплуатация машин БЦ", DataSource::AtBasePrices("Эксплуатация машин")),
    ("Смета №", DataSource::InTableHeader("Смета №")),
    ("Смета наименование", DataSource::InTableHeader("Смета наименование")),
    ("По смете в ц.2000г.", DataSource::Calculate),
    ("Выполнение работ в ц.2000г.", DataSource::Calculate),
    ("Акт №", DataSource::InTableHeader("Акт №")),
    ("Акт дата", DataSource::Calculate),
    ("Отчетный период начало", DataSource::Calculate),
    ("Отчетный период окончание", DataSource::Calculate),
    ("Метод расчета", DataSource::InTableHeader("Метод расчета")),
    ("Ссылка на папку", DataSource::Calculate),
    ("Ссылка на файл", DataSource::Calculate),
];

// В массиве выше перечислены далеко не все столбцы что будут в акте (там может быть все что угодно и в неизвестном количестве).
// В PART_1 мы перечислили только то, чему мы можем задать порядок, но есть столбцы, где мы хотим оставить тот порядок, который уже существует в актах.
// Поделим отсутсвующие столбцы на два вида: соответсвующие форме акта первого в выборке и те, которые в его форму не вписались.
// Столбцы, которые будут совпадать со структурой первого акта, получают больший приоритет и стремятся в левое положение таблицы.
// Другими словами, структура нашей шапки воспроизведет порядок итогов первого акта в выборке. А все что не вписальось в эту структуру будет помещено в крайние правые столбцы.
// Придется учесть, что у нас два вида данных в итогах: базовые и текущие цены. Проделаем описанное для каждого вида цены.
// И конечно, нажно проверять на присутсвие данных в PART_1, что-бы мы не включили в шапку отчета повторяющиеся названия.


pub fn first_file_summary_lines(act: &Vec<TotalsRow>) -> (Vec<&String>, Vec<&String>) {
    let (x, y) = REPORTING_FORM_PART_1
        .iter()
        .fold((Vec::new(), Vec::new()), |mut acc, (_, x)| {
            if let DataSource::AtBasePrices(x) = x {
                acc.0.push(*x)
            };

            if let DataSource::AtCurrentPrices(x) = x {
                acc.1.push(*x)
            };
            acc
        });


    act.into_iter()
        .fold((Vec::new(), Vec::new()), |mut acc, x| {
            if let Some(_) = x.base_price {
                acc.0.push(&x.name)
            }

            if let Some(_) = x.current_price {
                acc.1.push(&x.name)
            }
            acc
        })
}
